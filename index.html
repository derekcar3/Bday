<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy 33rd Birthday - Caf√© Literary Quest</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Georgia', serif;
            background: linear-gradient(135deg, #8B4513, #D2691E, #CD853F);
            overflow: hidden;
            touch-action: manipulation;
            user-select: none;
        }

        #gameContainer {
            width: 100vw;
            height: 100vh;
            position: relative;
            background: 
                radial-gradient(circle at 20% 20%, rgba(255,215,0,0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 60%, rgba(255,140,0,0.1) 0%, transparent 50%),
                linear-gradient(45deg, #8B4513 0%, #A0522D 50%, #8B4513 100%);
            background-attachment: fixed;
            transition: transform 0.1s ease-out;
        }

        .screen-shake {
            animation: screen-shake 0.5s ease-in-out;
        }

        @keyframes screen-shake {
            0% { transform: translate(0); }
            10% { transform: translate(-10px, -5px) rotate(-1deg); }
            20% { transform: translate(10px, 5px) rotate(1deg); }
            30% { transform: translate(-8px, 3px) rotate(-1deg); }
            40% { transform: translate(8px, -3px) rotate(1deg); }
            50% { transform: translate(-6px, 2px) rotate(-0.5deg); }
            60% { transform: translate(6px, -2px) rotate(0.5deg); }
            70% { transform: translate(-4px, 1px) rotate(-0.5deg); }
            80% { transform: translate(4px, -1px) rotate(0.5deg); }
            90% { transform: translate(-2px, 1px) rotate(0); }
            100% { transform: translate(0); }
        }

        .bookshelf {
            position: absolute;
            width: 80px;
            height: 150px;
            background: linear-gradient(90deg, #654321 0%, #8B4513 50%, #654321 100%);
            border: 3px solid #4A4A4A;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .bookshelf:before {
            content: '';
            position: absolute;
            top: 25px;
            left: 8px;
            right: 8px;
            height: 20px;
            background: repeating-linear-gradient(90deg, #FF6B6B 0px, #FF6B6B 10px, #4ECDC4 10px, #4ECDC4 20px, #45B7D1 20px, #45B7D1 30px, #96CEB4 30px, #96CEB4 40px);
            border-radius: 3px;
        }

        .bookshelf:after {
            content: '';
            position: absolute;
            bottom: 25px;
            left: 8px;
            right: 8px;
            height: 20px;
            background: repeating-linear-gradient(90deg, #DDA0DD 0px, #DDA0DD 10px, #F0E68C 10px, #F0E68C 20px, #FFB6C1 20px, #FFB6C1 30px, #98FB98 30px, #98FB98 40px);
            border-radius: 3px;
        }

        .cafe-table {
            position: absolute;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #8B4513 30%, #654321 70%);
            border-radius: 50%;
            border: 4px solid #4A4A4A;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .cafe-table:after {
            content: '‚òï';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        #player {
            position: absolute;
            width: 50px;
            height: 50px;
            background: linear-gradient(45deg, #FF6B9D, #FF8E53);
            border-radius: 50%;
            border: 4px solid #FFF;
            transition: all 0.15s ease-out;
            z-index: 100;
            box-shadow: 0 6px 12px rgba(0,0,0,0.4);
        }

        #player:before {
            content: 'üë©‚Äçü¶∞';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 28px;
        }

        .kid {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: 3px solid #FFF;
            transition: all 0.2s ease-out;
            z-index: 95;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #cassian {
            background: linear-gradient(45deg, #87CEEB, #4682B4);
        }

        #charlie {
            background: linear-gradient(45deg, #FFB6C1, #FF69B4);
        }

        #cassian:before {
            content: 'üë¶';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        #charlie:before {
            content: 'üëß';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .speech-bubble {
            position: absolute;
            background: white;
            border: 3px solid #FF69B4;
            border-radius: 15px;
            padding: 8px 12px;
            font-size: 12px;
            font-weight: bold;
            color: #8B008B;
            max-width: 120px;
            text-align: center;
            z-index: 150;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s ease;
        }

        .speech-bubble:after {
            content: '';
            position: absolute;
            bottom: -10px;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 0;
            border-left: 10px solid transparent;
            border-right: 10px solid transparent;
            border-top: 10px solid #FF69B4;
        }

        .speech-bubble.show {
            opacity: 1;
            transform: scale(1);
        }

        .collectible {
            position: absolute;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            animation: float 2s ease-in-out infinite;
            z-index: 50;
            transition: transform 0.1s ease;
        }

        .collectible:hover {
            transform: scale(1.1);
        }

        .book {
            background: linear-gradient(45deg, #4ECDC4, #45B7D1);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .book:before {
            content: 'üìö';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .coffee {
            background: linear-gradient(45deg, #D2691E, #8B4513);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .coffee:before {
            content: '‚òï';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .healthy-snack {
            background: linear-gradient(45deg, #98FB98, #90EE90);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .healthy-snack:before {
            content: 'ü•ó';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .running-shoe {
            background: linear-gradient(45deg, #FF1493, #FF69B4);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .running-shoe:before {
            content: 'üëü';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .apple {
            background: linear-gradient(45deg, #FF6347, #FF4500);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .apple:before {
            content: 'üçé';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        .water {
            background: linear-gradient(45deg, #87CEEB, #4682B4);
            border: 3px solid #FFF;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .water:before {
            content: 'üíß';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        /* Negative Items */
        .dirty-dish {
            background: linear-gradient(45deg, #FF0000, #DC143C);
            border: 3px solid #8B0000;
            box-shadow: 0 4px 8px rgba(139,0,0,0.5);
            animation: float 2s ease-in-out infinite, shake 0.5s ease-in-out infinite;
        }

        .dirty-dish:before {
            content: 'üçΩÔ∏è';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            filter: brightness(0.7) contrast(1.2);
        }

        .laundry {
            background: linear-gradient(45deg, #FF0000, #B22222);
            border: 3px solid #8B0000;
            box-shadow: 0 4px 8px rgba(139,0,0,0.5);
            animation: float 2s ease-in-out infinite, shake 0.7s ease-in-out infinite;
        }

        .laundry:before {
            content: 'üëï';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            filter: brightness(0.6) saturate(1.5);
        }
        .collectible:before {
    font-size: 32px !important; /* This will override all collectible icon sizes */
}

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-15px); }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0px) translateY(0px); }
            25% { transform: translateX(-2px) translateY(-2px); }
            75% { transform: translateX(2px) translateY(2px); }
        }

        .flex-hit {
            animation: flex-hit 0.3s ease-out;
        }

        @keyframes flex-hit {
            0% { transform: scale(1); }
            50% { transform: scale(1.3) rotate(5deg); }
            100% { transform: scale(1); }
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 200;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        #score, #timer {
            background: rgba(0,0,0,0.8);
            color: #FFD700;
            padding: 12px 18px;
            border-radius: 25px;
            font-size: 20px;
            font-weight: bold;
            border: 3px solid #FFD700;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        #popup {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, #FFE4E1, #FFF0F5);
            padding: 30px;
            border-radius: 20px;
            border: 4px solid #FF69B4;
            text-align: center;
            z-index: 300;
            display: none;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            max-width: 90%;
        }

        #popup h2 {
            color: #FF1493;
            margin-bottom: 15px;
            font-size: 24px;
        }

        #popup p {
            color: #8B008B;
            font-size: 18px;
            margin-bottom: 20px;
            line-height: 1.4;
        }

        #popup button {
            background: linear-gradient(45deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
        }

        #popup button:hover {
            transform: scale(1.05);
        }

        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #8B4513, #D2691E);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 400;
            text-align: center;
            padding: 20px;
        }

        #startScreen h1 {
            color: #FFD700;
            font-size: 28px;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }

        #startScreen p {
            color: #FFF;
            font-size: 16px;
            margin-bottom: 30px;
            line-height: 1.6;
        }

        #startButton {
            background: linear-gradient(45deg, #FF69B4, #FF1493);
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 30px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.2s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }

        #startButton:hover {
            transform: scale(1.1);
        }

        .particle {
            position: absolute;
            width: 6px;
            height: 6px;
            background: #FFD700;
            border-radius: 50%;
            pointer-events: none;
            animation: particle-float 3s ease-out forwards;
        }

        .negative-particle {
            background: #FF0000;
            animation: negative-particle-float 2s ease-out forwards;
        }

        @keyframes particle-float {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) scale(0);
            }
        }

        @keyframes negative-particle-float {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            100% {
                opacity: 0;
                transform: translateY(-80px) scale(0);
            }
        }

        @media (max-height: 600px) {
            #startScreen h1 { font-size: 24px; }
            #startScreen p { font-size: 14px; }
            #popup h2 { font-size: 20px; }
            #popup p { font-size: 16px; }
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>üéâ Happy 33rd Birthday! üéâ</h1>
        <p>Welcome to your personalized Caf√© Literary Quest!<br>
           Explore the charming Parisian bookstore caf√©,<br>
           collect books, coffee, and healthy treats!<br>
           Cassian and Charlie will cheer you on!<br><br>
           üëÜ Tap anywhere to move<br>
           üìö Collect good items for points<br>
           üçΩÔ∏è Avoid dirty dishes and laundry!<br>
           ‚è∞ Beat the clock!</p>
        <button id="startButton">Start Your Adventure!</button>
    </div>

    <div id="gameContainer">
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="timer">Time: 90</div>
        </div>
        <div id="player"></div>
        <div id="cassian" class="kid"></div>
        <div id="charlie" class="kid"></div>
    </div>

    <div id="popup">
        <h2 id="popupTitle"></h2>
        <p id="popupMessage"></p>
        <button onclick="closePopup()">Continue</button>
    </div>

    <script>
        // Game variables
        let score = 0;
        let timeLeft = 90;
        let gameRunning = false;
        let player = document.getElementById('player');
        let cassian = document.getElementById('cassian');
        let charlie = document.getElementById('charlie');
        let gameContainer = document.getElementById('gameContainer');
        let collectibles = [];
        let gameTimer;
        let spawnTimer;
        let speechTimer;
        
        // Player position with smoother tracking
        let playerX = window.innerWidth / 2 - 25;
        let playerY = window.innerHeight / 2 - 25;
        let targetX = playerX;
        let targetY = playerY;
        
        // Kids positions with more natural following
        let cassianX = playerX - 100;
        let cassianY = playerY + 80;
        let cassianVelX = 0;
        let cassianVelY = 0;
        let charlieX = playerX + 100;
        let charlieY = playerY - 80;
        let charlieVelX = 0;
        let charlieVelY = 0;
        
        // Movement history for more natural following
        let playerHistory = [];
        let maxHistoryLength = 30; // Frames of delay
        
        // Enhanced movement physics
        const FOLLOW_STRENGTH = 0.02;
        const DAMPING = 0.92;
        const MAX_SPEED = 1;
        const MIN_DISTANCE = 50;
        const PLAYER_SMOOTHING = 0.2; // For smoother player movement
        
        // Track occupied spawn areas
        let spawnAreas = {
            positive: [],
            negative: []
        };
        
        // Speech bubble messages for kids
        const encouragingMessages = [
            "Go Mama! üí™",
            "Love you Mama! üíï",
            "Happy Birthday! üéÇ"
        ];
        
        const winMessages = [
            "Happy Birthday From Charlie, Cassian and Dada! üéâüíï",
            "You completed your literary caf√© adventure! üìö‚òï",
            "33 years of being absolutely wonderful! ‚ú®üéÇ"
        ];

        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine') {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }

        function playCollectSound() {
            playSound(800, 0.2);
            setTimeout(() => playSound(1200, 0.1), 100);
        }

        function playNegativeSound() {
            playSound(200, 0.3, 'sawtooth');
            playSound(150, 0.4, 'square');
        }

        function playWinSound() {
            const notes = [523, 659, 784, 1047];
            notes.forEach((note, index) => {
                setTimeout(() => playSound(note, 0.3), index * 200);
            });
        }

        function shakeScreen() {
            gameContainer.classList.add('screen-shake');
            setTimeout(() => {
                gameContainer.classList.remove('screen-shake');
            }, 500);
        }

        // Initialize game
        function initGame() {
            // Initialize player history
            for (let i = 0; i < maxHistoryLength; i++) {
                playerHistory.push({ x: playerX, y: playerY });
            }
            
            updatePlayerPosition();
            updateKidsPositions();
            createStaticElements();
            
            // Touch controls with better responsiveness
            gameContainer.addEventListener('touchstart', handleTouch, { passive: false });
            gameContainer.addEventListener('touchmove', handleTouch, { passive: false });
            gameContainer.addEventListener('click', handleClick);
            
            document.getElementById('startButton').addEventListener('click', startGame);
        }

        function createStaticElements() {
            // Create bookshelves in organized pattern
            const positions = [
                {x: 50, y: 120}, {x: 50, y: 320}, {x: 50, y: 520},
                {x: window.innerWidth - 130, y: 150}, {x: window.innerWidth - 130, y: 350}
            ];
            
            positions.forEach(pos => {
                if (pos.y < window.innerHeight - 170) {
                    const bookshelf = document.createElement('div');
                    bookshelf.className = 'bookshelf';
                    bookshelf.style.left = pos.x + 'px';
                    bookshelf.style.top = pos.y + 'px';
                    gameContainer.appendChild(bookshelf);
                }
            });
            
            // Create caf√© tables with better positioning
            const tablePositions = [
                {x: 200, y: 180}, {x: 200, y: 350}, {x: 200, y: 520},
                {x: window.innerWidth - 260, y: 180}, {x: window.innerWidth - 260, y: 350},
                {x: window.innerWidth/2 - 30, y: 200}, {x: window.innerWidth/2 - 30, y: 400}
            ];
            
            const filteredPositions = [];
            tablePositions.forEach(newPos => {
                if (newPos.x > 100 && newPos.x < window.innerWidth - 160 && newPos.y < window.innerHeight - 120) {
                    let canPlace = true;
                    filteredPositions.forEach(existingPos => {
                        const distance = Math.sqrt(Math.pow(newPos.x - existingPos.x, 2) + Math.pow(newPos.y - existingPos.y, 2));
                        if (distance < 120) {
                            canPlace = false;
                        }
                    });
                    if (canPlace) {
                        filteredPositions.push(newPos);
                    }
                }
            });
            
            filteredPositions.forEach(pos => {
                const table = document.createElement('div');
                table.className = 'cafe-table';
                table.style.left = pos.x + 'px';
                table.style.top = pos.y + 'px';
                gameContainer.appendChild(table);
            });
        }

        function handleTouch(e) {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touch = e.touches[0] || e.changedTouches[0];
            // Get the actual touch position relative to the game container
            const rect = gameContainer.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            setPlayerTarget(touchX, touchY);
        }
        
        function handleClick(e) {
            if (!gameRunning) return;
            
            // Get click position relative to the game container
            const rect = gameContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            setPlayerTarget(clickX, clickY);
        }
        
        function setPlayerTarget(x, y) {
            // Center the character on the touch/click point with proper boundaries
            // Character is 50px wide/tall, so offset by 25px to center it
            targetX = Math.max(25, Math.min(window.innerWidth - 25, x - 25));
            targetY = Math.max(90, Math.min(window.innerHeight - 25, y - 25));
        }

        function updatePlayerPosition() {
            // Smooth interpolation to target position
            playerX += (targetX - playerX) * PLAYER_SMOOTHING;
            playerY += (targetY - playerY) * PLAYER_SMOOTHING;
            
            // Update player history for kids to follow
            playerHistory.push({ x: playerX, y: playerY });
            if (playerHistory.length > maxHistoryLength) {
                playerHistory.shift();
            }
            
            player.style.left = playerX + 'px';
            player.style.top = playerY + 'px';
        }

        function updateKidsPositions() {
            // Get delayed positions from player history for more natural following
            const cassianDelay = Math.floor(maxHistoryLength * 0.6); // Cassian follows with 60% delay
            const charlieDelay = Math.floor(maxHistoryLength * 0.8); // Charlie follows with 80% delay
            
            const cassianTarget = playerHistory[Math.max(0, playerHistory.length - cassianDelay - 1)];
            const charlieTarget = playerHistory[Math.max(0, playerHistory.length - charlieDelay - 1)];
            
            // Add some wandering behavior
            const time = Date.now() * 0.001;
            const cassianTargetX = cassianTarget.x + Math.sin(time * 0.5) * 25;
            const cassianTargetY = cassianTarget.y + Math.cos(time * 0.7) * 20;
            const charlieTargetX = charlieTarget.x + Math.cos(time * 0.6) * 30;
            const charlieTargetY = charlieTarget.y + Math.sin(time * 0.4) * 25;
            
            // Enhanced physics for Cassian
            const cassianDist = Math.sqrt(Math.pow(cassianTargetX - cassianX, 2) + Math.pow(cassianTargetY - cassianY, 2));
            const cassianForceMultiplier = Math.min(cassianDist / 50, 1.5); // Stronger force when farther away
            
            const cassianForceX = (cassianTargetX - cassianX) * FOLLOW_STRENGTH * cassianForceMultiplier;
            const cassianForceY = (cassianTargetY - cassianY) * FOLLOW_STRENGTH * cassianForceMultiplier;
            
            cassianVelX += cassianForceX;
            cassianVelY += cassianForceY;
            cassianVelX *= DAMPING;
            cassianVelY *= DAMPING;
            
            // Enhanced physics for Charlie
            const charlieDist = Math.sqrt(Math.pow(charlieTargetX - charlieX, 2) + Math.pow(charlieTargetY - charlieY, 2));
            const charlieForceMultiplier = Math.min(charlieDist / 50, 1.5);
            
            const charlieForceX = (charlieTargetX - charlieX) * FOLLOW_STRENGTH * charlieForceMultiplier;
            const charlieForceY = (charlieTargetY - charlieY) * FOLLOW_STRENGTH * charlieForceMultiplier;
            
            charlieVelX += charlieForceX;
            charlieVelY += charlieForceY;
            charlieVelX *= DAMPING;
            charlieVelY *= DAMPING;
            
            // Limit speeds with dynamic adjustment
            const cassianSpeed = Math.sqrt(cassianVelX * cassianVelX + cassianVelY * cassianVelY);
            const maxCassianSpeed = MAX_SPEED * (cassianDist > 100 ? 1.3 : 1); // Speed up when far behind
            if (cassianSpeed > maxCassianSpeed) {
                cassianVelX = (cassianVelX / cassianSpeed) * maxCassianSpeed;
                cassianVelY = (cassianVelY / cassianSpeed) * maxCassianSpeed;
            }
            
            const charlieSpeed = Math.sqrt(charlieVelX * charlieVelX + charlieVelY * charlieVelY);
            const maxCharlieSpeed = MAX_SPEED * (charlieDist > 100 ? 1.3 : 1);
            if (charlieSpeed > maxCharlieSpeed) {
                charlieVelX = (charlieVelX / charlieSpeed) * maxCharlieSpeed;
                charlieVelY = (charlieVelY / charlieSpeed) * maxCharlieSpeed;
            }
            
            // Apply velocities
            cassianX += cassianVelX;
            cassianY += cassianVelY;
            charlieX += charlieVelX;
            charlieY += charlieVelY;
            
            // Improved collision avoidance between kids
            const distanceBetweenKids = Math.sqrt(Math.pow(cassianX - charlieX, 2) + Math.pow(cassianY - charlieY, 2));
            if (distanceBetweenKids < MIN_DISTANCE) {
                const angle = Math.atan2(charlieY - cassianY, charlieX - cassianX);
                const overlap = MIN_DISTANCE - distanceBetweenKids;
                const pushDistance = overlap / 2;
                
                // Push apart with momentum
                const pushForce = 0.3;
                cassianX -= Math.cos(angle) * pushDistance;
                cassianY -= Math.sin(angle) * pushDistance;
                charlieX += Math.cos(angle) * pushDistance;
                charlieY += Math.sin(angle) * pushDistance;
                
                // Add separation to velocities
                cassianVelX -= Math.cos(angle) * pushForce;
                cassianVelY -= Math.sin(angle) * pushForce;
                charlieVelX += Math.cos(angle) * pushForce;
                charlieVelY += Math.sin(angle) * pushForce;
            }
            
            // Keep kids on screen with bouncing - update these boundary checks
            if (cassianX < 22.5) {
                cassianX = 22.5;
                cassianVelX = Math.abs(cassianVelX) * 0.8;
            }
            if (cassianX > window.innerWidth - 22.5) {
                cassianX = window.innerWidth - 22.5;
                cassianVelX = -Math.abs(cassianVelX) * 0.8;
            }
            if (cassianY < 90) {
                cassianY = 90;
                cassianVelY = Math.abs(cassianVelY) * 0.8;
            }
            if (cassianY > window.innerHeight - 22.5) {
                cassianY = window.innerHeight - 22.5;
                cassianVelY = -Math.abs(cassianVelY) * 0.8;
            }
            
            if (charlieX < 22.5) {
                charlieX = 22.5;
                charlieVelX = Math.abs(charlieVelX) * 0.8;
            }
            if (charlieX > window.innerWidth - 22.5) {
                charlieX = window.innerWidth - 22.5;
                charlieVelX = -Math.abs(charlieVelX) * 0.8;
            }
            if (charlieY < 90) {
                charlieY = 90;
                charlieVelY = Math.abs(charlieVelY) * 0.8;
            }
            if (charlieY > window.innerHeight - 22.5) {
                charlieY = window.innerHeight - 22.5;
                charlieVelY = -Math.abs(charlieVelY) * 0.8;
            }
            
            // Update DOM positions
            cassian.style.left = cassianX + 'px';
            cassian.style.top = cassianY + 'px';
            charlie.style.left = charlieX + 'px';
            charlie.style.top = charlieY + 'px';
        }

        function showSpeechBubble(kid, message) {
            const existingBubble = kid.querySelector('.speech-bubble');
            if (existingBubble) {
                existingBubble.remove();
            }
            
            const bubble = document.createElement('div');
            bubble.className = 'speech-bubble';
            bubble.textContent = message;
            bubble.style.bottom = '55px';
            bubble.style.left = '50%';
            bubble.style.transform = 'translateX(-50%)';
            
            kid.appendChild(bubble);
            
            setTimeout(() => {
                bubble.classList.add('show');
            }, 50);
            
            setTimeout(() => {
                bubble.classList.remove('show');
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                }, 300);
            }, 3000);
        }

        function startGame() {
            document.getElementById('startScreen').style.display = 'none';
            gameRunning = true;
            score = 0;
            timeLeft = 90;
            spawnAreas = { positive: [], negative: [] };
            
            if (audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            updateScore();
            updateTimer();
            
            gameTimer = setInterval(() => {
                timeLeft--;
                updateTimer();
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            spawnTimer = setInterval(spawnCollectible, 400);
            
            speechTimer = setInterval(() => {
                if (Math.random() < 0.3) {
                    const kid = Math.random() < 0.5 ? cassian : charlie;
                    const message = encouragingMessages[Math.floor(Math.random() * encouragingMessages.length)];
                    showSpeechBubble(kid, message);
                }
            }, 4000);
            
            setTimeout(() => {
                showSpeechBubble(cassian, "Go Mom! üí™");
            }, 1000);
            setTimeout(() => {
                showSpeechBubble(charlie, "Love you! üíï");
            }, 2000);
        }

        function spawnCollectible() {
            if (!gameRunning) return;
            
            const positiveTypes = ['book', 'coffee', 'healthy-snack', 'running-shoe', 'apple', 'water'];
            const negativeTypes = ['dirty-dish', 'laundry'];
            
            const isPositive = Math.random() < 0.75;
            const types = isPositive ? positiveTypes : negativeTypes;
            const type = types[Math.floor(Math.random() * types.length)];
            
            const collectible = document.createElement('div');
            collectible.className = `collectible ${type}`;
            
            // Enhanced spawn positioning to prevent ALL overlaps
            let x, y, attempts = 0;
            let validPosition = false;
            const ITEM_SIZE = 45; // Size of collectible items
            const MIN_SPACING = 80; // Minimum distance between items
            
            do {
                x = Math.random() * (window.innerWidth - 100) + 50;
                y = Math.random() * (window.innerHeight - 200) + 120;
                attempts++;
                
                validPosition = !isNearStaticElement(x, y) && 
                               !isNearAnyCollectibles(x, y, MIN_SPACING) &&
                               !isNearPlayer(x, y);
                
            } while (!validPosition && attempts < 50); // Increased attempts
            
            if (!validPosition) {
                console.log("Could not find valid spawn position, skipping this spawn");
                return; // Skip spawn if no valid position found
            }
            
            collectible.style.left = x + 'px';
            collectible.style.top = y + 'px';
            
            gameContainer.appendChild(collectible);
            collectibles.push(collectible);
            
            const lifetime = 8000 + Math.random() * 4000;
            setTimeout(() => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                    const index = collectibles.indexOf(collectible);
                    if (index > -1) collectibles.splice(index, 1);
                }
            }, lifetime);
        }

        function isNearAnyCollectibles(x, y, minDistance) {
            // Check against ALL existing collectibles using their actual positions
            for (let collectible of collectibles) {
                // Get the collectible's position from its style properties
                const existingX = parseInt(collectible.style.left) + 22.5; // center of 45px item
                const existingY = parseInt(collectible.style.top) + 22.5;  // center of 45px item
                
                const distance = Math.sqrt(Math.pow(x - existingX, 2) + Math.pow(y - existingY, 2));
                if (distance < minDistance) {
                    console.log(`Overlap detected: distance ${distance} < ${minDistance}`);
                    return true; // Too close to existing item
                }
            }
            return false; // Safe to spawn here
        }

        function isNearStaticElement(x, y) {
            const MIN_DISTANCE_FROM_STATIC = 100; // Minimum distance from tables/bookshelves
            
            const elements = document.querySelectorAll('.cafe-table, .bookshelf');
            for (let element of elements) {
                // Get static element position from style properties
                const elementX = parseInt(element.style.left) + (element.classList.contains('cafe-table') ? 30 : 40); // center
                const elementY = parseInt(element.style.top) + (element.classList.contains('cafe-table') ? 30 : 75);  // center
                
                const distance = Math.sqrt(Math.pow(x - elementX, 2) + Math.pow(y - elementY, 2));
                if (distance < MIN_DISTANCE_FROM_STATIC) {
                    return true;
                }
            }
            return false;
        }
        
        function isNearPlayer(x, y) {
            const MIN_DISTANCE_FROM_PLAYER = 120; // Don't spawn too close to player
            const MIN_DISTANCE_FROM_KIDS = 100;   // Don't spawn too close to kids
            
            // Use actual game coordinates, not screen coordinates
            const playerCenterX = playerX + 25;
            const playerCenterY = playerY + 25;
            const cassianCenterX = cassianX + 22.5;
            const cassianCenterY = cassianY + 22.5;
            const charlieCenterX = charlieX + 22.5;
            const charlieCenterY = charlieY + 22.5;
            
            const playerDistance = Math.sqrt(Math.pow(x - playerCenterX, 2) + Math.pow(y - playerCenterY, 2));
            const cassianDistance = Math.sqrt(Math.pow(x - cassianCenterX, 2) + Math.pow(y - cassianCenterY, 2));
            const charlieDistance = Math.sqrt(Math.pow(x - charlieCenterX, 2) + Math.pow(y - charlieCenterY, 2));
            
            return playerDistance < MIN_DISTANCE_FROM_PLAYER || 
                   cassianDistance < MIN_DISTANCE_FROM_KIDS || 
                   charlieDistance < MIN_DISTANCE_FROM_KIDS;
        }

        function checkCollisions() {
            collectibles.forEach((collectible, index) => {
                const rect1 = player.getBoundingClientRect();
                const rect2 = collectible.getBoundingClientRect();
                
                if (rect1.left < rect2.right && 
                    rect1.right > rect2.left && 
                    rect1.top < rect2.bottom && 
                    rect1.bottom > rect2.top) {
                    
                    collectCollectible(collectible, index);
                }
            });
        }

        function collectCollectible(collectible, index) {
            const type = collectible.classList[1];
            let points = 0;
            let isNegative = false;
            
            switch(type) {
                case 'book': points = 25; break;
                case 'coffee': points = 20; break;
                case 'healthy-snack': points = 30; break;
                case 'running-shoe': points = 35; break;
                case 'apple': points = 15; break;
                case 'water': points = 15; break;
                case 'dirty-dish': points = -20; isNegative = true; break;
                case 'laundry': points = -25; isNegative = true; break;
            }
            
            score += points;
            updateScore();
            
            if (isNegative) {
                playNegativeSound();
                shakeScreen();
                collectible.classList.add('flex-hit');
                createNegativeParticles(collectible);
                
                const kid = Math.random() < 0.5 ? cassian : charlie;
                const negativeMessages = ["Laundry is annoying!", "Let Dada Do Dishes üö´", "Yucky! ü§¢"];
                const message = negativeMessages[Math.floor(Math.random() * negativeMessages.length)];
                showSpeechBubble(kid, message);
            } else {
                playCollectSound();
                createParticles(collectible);
                
                if (Math.random() < 0.4) {
                    const kid = Math.random() < 0.5 ? cassian : charlie;
                    const positiveMessages = ["Great job Mama! üåü", "Happy Birthday Mama!!"];
                    const message = positiveMessages[Math.floor(Math.random() * positiveMessages.length)];
                    showSpeechBubble(kid, message);
                }
            }
            
            setTimeout(() => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                }
            }, 100);
            collectibles.splice(index, 1);
        }

        function createParticles(element) {
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = (rect.left + rect.width/2 + Math.random() * 40 - 20) + 'px';
                particle.style.top = (rect.top + rect.height/2 + Math.random() * 40 - 20) + 'px';
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 3000);
            }
        }

        function createNegativeParticles(element) {
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle negative-particle';
                particle.style.left = (rect.left + rect.width/2 + Math.random() * 30 - 15) + 'px';
                particle.style.top = (rect.top + rect.height/2 + Math.random() * 30 - 15) + 'px';
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 2000);
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
        }

        function updateTimer() {
            document.getElementById('timer').textContent = `Time: ${timeLeft}`;
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameTimer);
            clearInterval(spawnTimer);
            clearInterval(speechTimer);
            
            playWinSound();
            
            showSpeechBubble(cassian, "You did great! üèÜ");
            showSpeechBubble(charlie, "Love you Mom! üíï");
            
            let finalMessage = "";
            if (score >= 500) {
                finalMessage = winMessages[0];
            } else if (score >= 200) {
                finalMessage = winMessages[1];
            } else {
                finalMessage = winMessages[2];
            }
            
            setTimeout(() => {
                showPopup("üéâ Game Complete! üéâ", 
                    `${finalMessage}<br><br>Final Score: ${score}<br>You're amazing at 33! üíï<br><br>Cassian and Charlie are so proud of you!`);
            }, 2000);
        }

        function showPopup(title, message) {
            document.getElementById('popupTitle').textContent = title;
            document.getElementById('popupMessage').innerHTML = message;
            document.getElementById('popup').style.display = 'block';
        }

        function closePopup() {
            document.getElementById('popup').style.display = 'none';
        }

        // Game loop
        function gameLoop() {
            if (gameRunning) {
                updatePlayerPosition();
                updateKidsPositions();
                checkCollisions();
            }
            requestAnimationFrame(gameLoop);
        }

        // Initialize everything
        window.addEventListener('load', () => {
            initGame();
            gameLoop();
        });

        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                targetX = Math.min(targetX, window.innerWidth - 75);
                targetY = Math.min(targetY, window.innerHeight - 75);
                playerX = Math.min(playerX, window.innerWidth - 75);
                playerY = Math.min(playerY, window.innerHeight - 75);
            }, 100);
        });
    </script>
</body>
</html>
