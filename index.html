<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Happy 33rd Birthday - Caf√© Literary Quest</title>
    <style>
            * {
                margin: 0;
                padding: 0;
                box-sizing: border-box;
            }
    
            body {
                font-family: 'Georgia', serif;
                background: linear-gradient(135deg, #8B4513, #D2691E, #CD853F);
                overflow: hidden;
                touch-action: manipulation;
                user-select: none;
            }
    
            #gameContainer {
                width: 100vw;
                height: 100vh;
                position: relative;
                background: 
                    /* Clean coffee shop atmosphere */
                    linear-gradient(135deg, #F5E6D3 0%, #E8D5B7 25%, #D4C4A8 50%, #C9B99C 75%, #B8A082 100%);
                background-attachment: fixed;
                transition: transform 0.1s ease-out;
            }
    
            .screen-shake {
                animation: screen-shake 0.5s ease-in-out;
            }

            /* Add this new class for content that should shake */
            .screen-shake .shake-content {
                animation: screen-shake-content 0.5s ease-in-out;
            }
        
        /* Keep the original animation for the container */
        @keyframes screen-shake {
            0% { transform: translate(0); }
            10% { transform: translate(-10px, -5px) rotate(-1deg); }
            20% { transform: translate(10px, 5px) rotate(1deg); }
            30% { transform: translate(-8px, 3px) rotate(-1deg); }
            40% { transform: translate(8px, -3px) rotate(1deg); }
            50% { transform: translate(-6px, 2px) rotate(-0.5deg); }
            60% { transform: translate(6px, -2px) rotate(0.5deg); }
            70% { transform: translate(-4px, 1px) rotate(-0.5deg); }
            80% { transform: translate(4px, -1px) rotate(0.5deg); }
            90% { transform: translate(-2px, 1px) rotate(0); }
            100% { transform: translate(0); }
        }
        
        /* New animation that only affects game elements, not UI */
        @keyframes screen-shake-content {
            0% { transform: translate(0); }
            10% { transform: translate(-8px, -4px); }
            20% { transform: translate(8px, 4px); }
            30% { transform: translate(-6px, 2px); }
            40% { transform: translate(6px, -2px); }
            50% { transform: translate(-4px, 1px); }
            60% { transform: translate(4px, -1px); }
            70% { transform: translate(-2px, 1px); }
            80% { transform: translate(2px, -1px); }
            90% { transform: translate(-1px, 0px); }
            100% { transform: translate(0); }
        }
        
        /* Ensure UI stays fixed during shake */
        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            z-index: 200;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            background: rgba(0,0,0,0.3);
            padding: 18px;
            border-radius: 25px;
            backdrop-filter: blur(15px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            height: 80px;
            /* Add this to prevent shake interference */
            transform: translateZ(0);
            will-change: auto;
        }

            .tree {
                position: absolute;
                width: 80px;
                height: 100px;
                z-index: 5;
            }

            .tree:before {
                content: 'üå≥';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 60px;
                filter: drop-shadow(0 3px 6px rgba(0,0,0,0.3));
            }

            .cloud {
                position: absolute;
                z-index: 2;
                animation: cloud-float 20s linear infinite;
            }

            .cloud:before {
                content: '‚òÅÔ∏è';
                font-size: 40px;
                filter: drop-shadow(0 2px 4px rgba(0,0,0,0.2));
            }

            @keyframes cloud-float {
                0% { transform: translateX(-80px); }
                100% { transform: translateX(calc(100vw + 80px)); }
            }
    
            #player {
                position: absolute;
                width: 70px;
                height: 70px;
                background: linear-gradient(45deg, #FF6B9D, #FF8E53);
                border-radius: 50%;
                border: 4px solid #FFF;
                transition: all 0.15s ease-out;
                z-index: 100;
                box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            }
    
            #player:before {
                content: 'üë©‚Äçü¶∞';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .kid {
                position: absolute;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                border: 3px solid #FFF;
                transition: all 0.2s ease-out;
                z-index: 95;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            #cassian {
                background: linear-gradient(45deg, #87CEEB, #4682B4);
            }
    
            #charlie {
                background: linear-gradient(45deg, #FFB6C1, #FF69B4);
            }
    
            #cassian:before {
                content: 'üë¶';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 32px;
            }
    
            #charlie:before {
                content: 'üëß';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 32px;
            }
    
            .speech-bubble {
                position: absolute;
                background: white;
                border: 3px solid #FF69B4;
                border-radius: 15px;
                padding: 8px 12px;
                font-size: 12px;
                font-weight: bold;
                color: #8B008B;
                max-width: 120px;
                text-align: center;
                z-index: 150;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                opacity: 0;
                transform: scale(0);
                transition: all 0.3s ease;
            }
    
            .speech-bubble:after {
                content: '';
                position: absolute;
                bottom: -10px;
                left: 50%;
                transform: translateX(-50%);
                width: 0;
                height: 0;
                border-left: 10px solid transparent;
                border-right: 10px solid transparent;
                border-top: 10px solid #FF69B4;
            }
    
            .speech-bubble.show {
                opacity: 1;
                transform: scale(1);
            }

            .score-popup {
                position: absolute;
                font-size: 24px;
                font-weight: bold;
                pointer-events: none;
                z-index: 200;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
                animation: score-float 1.5s ease-out forwards;
            }

            .score-popup.positive {
                color: #FFD700;
            }

            .score-popup.negative {
                color: #FF4444;
            }

            @keyframes score-float {
                0% {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translateY(-80px) scale(1.2);
                }
            }
    
            .collectible {
                position: absolute;
                width: 60px;
                height: 60px;
                border-radius: 50%;
                animation: float 2s ease-in-out infinite;
                z-index: 50;
                transition: transform 0.1s ease;
            }
    
            .collectible:hover {
                transform: scale(1.1);
            }
    
            .book {
                background: linear-gradient(45deg, #4ECDC4, #45B7D1);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .book:before {
                content: 'üìö';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .coffee {
                background: linear-gradient(45deg, #D2691E, #8B4513);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .coffee:before {
                content: '‚òï';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .healthy-snack {
                background: linear-gradient(45deg, #98FB98, #90EE90);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .healthy-snack:before {
                content: 'ü•ó';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .running-shoe {
                background: linear-gradient(45deg, #FF1493, #FF69B4);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .running-shoe:before {
                content: 'üëü';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .apple {
                background: linear-gradient(45deg, #FF6347, #FF4500);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .apple:before {
                content: 'üçé';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            .water {
                background: linear-gradient(45deg, #87CEEB, #4682B4);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .water:before {
                content: 'üíß';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }

            .flying-airplane {
                position: absolute;
                width: 80px;
                height: 80px;
                background: linear-gradient(45deg, #87CEEB, #4169E1);
                border-radius: 50%;
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                z-index: 120;
                animation: fly-across 8s linear forwards;
            }

            .flying-airplane:before {
                content: '‚úàÔ∏è';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 50px;
            }

            @keyframes fly-across {
                0% { 
                    left: -100px; 
                    transform: translateY(0) rotate(0deg);
                }
                25% {
                    transform: translateY(-10px) rotate(5deg);
                }
                50% {
                    transform: translateY(5px) rotate(-2deg);
                }
                75% {
                    transform: translateY(-5px) rotate(3deg);
                }
                100% { 
                    left: calc(100vw + 100px);
                    transform: translateY(0) rotate(0deg);
                }
            }

            .birthday-cake {
                background: linear-gradient(45deg, #FFB6C1, #FF69B4);
                border: 3px solid #FFF;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
            }
    
            .birthday-cake:before {
                content: 'üéÇ';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
            }
    
            /* Negative Items - Same size as positive but with special styling */
            .dirty-dish {
                background: linear-gradient(45deg, #FF0000, #DC143C);
                border: 3px solid #8B0000;
                box-shadow: 0 4px 8px rgba(139,0,0,0.5);
                animation: float 2s ease-in-out infinite, shake 0.5s ease-in-out infinite;
            }
    
            .dirty-dish:before {
                content: 'üçΩÔ∏è';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
                filter: brightness(0.7) contrast(1.2);
            }
    
            .laundry {
                background: linear-gradient(45deg, #FF0000, #B22222);
                border: 3px solid #8B0000;
                box-shadow: 0 4px 8px rgba(139,0,0,0.5);
                animation: float 2s ease-in-out infinite, shake 0.7s ease-in-out infinite;
            }
    
            .laundry:before {
                content: 'üëï';
                position: absolute;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 40px;
                filter: brightness(0.6) saturate(1.5);
            }
    
            @keyframes float {
                0%, 100% { transform: translateY(0px); }
                50% { transform: translateY(-15px); }
            }
    
            @keyframes shake {
                0%, 100% { transform: translateX(0px) translateY(0px); }
                25% { transform: translateX(-2px) translateY(-2px); }
                75% { transform: translateX(2px) translateY(2px); }
            }
    
            .flex-hit {
                animation: flex-hit 0.3s ease-out;
            }
    
            @keyframes flex-hit {
                0% { transform: scale(1); }
                50% { transform: scale(1.3) rotate(5deg); }
                100% { transform: scale(1); }
            }
    
            #ui {
                position: fixed;
                top: 20px;
                left: 20px;
                right: 20px;
                z-index: 200;
                display: flex;
                justify-content: space-between;
                align-items: center;
                flex-wrap: wrap;
                gap: 10px;
                background: rgba(0,0,0,0.3);
                padding: 18px;
                border-radius: 25px;
                backdrop-filter: blur(15px);
                box-shadow: 0 8px 25px rgba(0,0,0,0.4);
                height: 80px;
            }
    
            #score, #timer, #highScore {
                background: rgba(0,0,0,0.9);
                color: #FFD700;
                padding: 10px 15px;
                border-radius: 20px;
                font-size: 16px;
                font-weight: bold;
                border: 2px solid #FFD700;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                backdrop-filter: blur(5px);
            }
    
            #restartButton {
                background: linear-gradient(45deg, #FF69B4, #FF1493);
                color: white;
                border: none;
                padding: 12px 18px;
                border-radius: 20px;
                font-size: 14px;
                font-weight: bold;
                cursor: pointer;
                transition: all 0.2s;
                box-shadow: 0 4px 8px rgba(0,0,0,0.3);
                user-select: none;
            }
    
            #restartButton:hover {
                transform: scale(1.05);
                box-shadow: 0 6px 12px rgba(0,0,0,0.4);
            }

            #restartButton:active {
                transform: scale(0.95);
                background: linear-gradient(45deg, #FF1493, #FF69B4);
            }
    
            #popup {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: linear-gradient(135deg, #FFE4E1, #FFF0F5);
                padding: 30px;
                border-radius: 20px;
                border: 4px solid #FF69B4;
                text-align: center;
                z-index: 300;
                display: none;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                max-width: 90%;
                width: 400px;
                min-height: 250px;
            }
    
            #popup h2 {
                color: #FF1493;
                margin-bottom: 15px;
                font-size: 24px;
            }
    
            #popup p {
                color: #8B008B;
                font-size: 18px;
                margin-bottom: 20px;
                line-height: 1.4;
            }
    
            #popup button {
                background: linear-gradient(45deg, #FF69B4, #FF1493);
                color: white;
                border: none;
                padding: 12px 25px;
                border-radius: 25px;
                font-size: 16px;
                font-weight: bold;
                cursor: pointer;
                transition: transform 0.2s;
            }
    
            #popup button:hover {
                transform: scale(1.05);
            }
    
            #startScreen {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: linear-gradient(135deg, #8B4513, #D2691E);
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                z-index: 400;
                text-align: center;
                padding: 20px;
            }
    
            #startScreen h1 {
                color: #FFD700;
                font-size: 28px;
                margin-bottom: 20px;
                text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            }
    
            #startScreen p {
                color: #FFF;
                font-size: 16px;
                margin-bottom: 30px;
                line-height: 1.6;
            }
    
            #startButton {
                background: linear-gradient(45deg, #FF69B4, #FF1493);
                color: white;
                border: none;
                padding: 15px 30px;
                border-radius: 30px;
                font-size: 20px;
                font-weight: bold;
                cursor: pointer;
                transition: transform 0.2s;
                box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            }
    
            #startButton:hover {
                transform: scale(1.1);
            }
    
            .particle {
                position: absolute;
                width: 6px;
                height: 6px;
                background: #FFD700;
                border-radius: 50%;
                pointer-events: none;
                animation: particle-float 3s ease-out forwards;
            }
    
            .negative-particle {
                background: #FF0000;
                animation: negative-particle-float 2s ease-out forwards;
            }
    
            @keyframes particle-float {
                0% {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translateY(-100px) scale(0);
                }
            }
    
            @keyframes negative-particle-float {
                0% {
                    opacity: 1;
                    transform: translateY(0) scale(1);
                }
                100% {
                    opacity: 0;
                    transform: translateY(-80px) scale(0);
                }
            }
    
            @media (max-height: 600px) {
                #startScreen h1 { font-size: 24px; }
                #startScreen p { font-size: 14px; }
                #popup h2 { font-size: 20px; }
                #popup p { font-size: 16px; }
                #ui { gap: 5px; padding: 12px; height: 70px; }
                #score, #timer, #highScore { font-size: 14px; padding: 8px 12px; }
            }
    </style>
</head>
<body>
    <div id="startScreen">
        <h1>üéâ Happy 33rd Birthday Mama! üéâ</h1>
        <p>Explore this charming outdoor caf√© garden,<br>
           collect books, coffee, and all you're favorite things!<br>
           Nova and Charlie will cheer you on!<br><br>
           üëÜ Tap anywhere to move<br>
           üìö Collect good items for points<br>
           üçΩÔ∏è Avoid dirty dishes and laundry!<br>
           ‚úàÔ∏è Watch for special flying airplanes!<br>
           ‚è∞ Beat the clock!</p>
        <button id="startButton">Start Your Adventure!</button>
    </div>

    <div id="gameContainer">
        <div id="ui">
            <div id="score">Score: 0</div>
            <div id="timer">Time: 60</div>
            <div id="highScore">High Score: 0</div>
            <button id="restartButton">Restart Game</button>
        </div>
        <!-- Wrap the game content that should shake -->
        <div class="shake-content">
            <div id="player"></div>
            <div id="cassian" class="kid"></div>
            <div id="charlie" class="kid"></div>
        </div>
    </div>

    <div id="popup">
        <h2 id="popupTitle"></h2>
        <p id="popupMessage"></p>
        <button onclick="closePopup()">Continue</button>
    </div>

    <script>
        // Game variables
        let score = 0;
        let timeLeft = 60;
        let highScore = localStorage.getItem('cafeQuestHighScore') || 0;
        let gameRunning = false;
        let player = document.getElementById('player');
        let cassian = document.getElementById('cassian');
        let charlie = document.getElementById('charlie');
        let gameContainer = document.getElementById('gameContainer');
        let collectibles = [];
        let gameTimer;
        let spawnTimer;
        let speechTimer;
        let airplaneTimer;
        let cloudTimer;
        let currentSpeakingKid = null;
        
        // Player position with smoother tracking
        let playerX = window.innerWidth / 2 - 35;
        let playerY = window.innerHeight / 2 - 35;
        let targetX = playerX;
        let targetY = playerY;
        
        // Kids positions with more natural following
        let cassianX = playerX - 120;
        let cassianY = playerY + 100;
        let cassianVelX = 0;
        let cassianVelY = 0;
        let charlieX = playerX + 120;
        let charlieY = playerY - 100;
        let charlieVelX = 0;
        let charlieVelY = 0;
        
        // Movement history for more natural following
        let playerHistory = [];
        let maxHistoryLength = 30; // Frames of delay
        
        // Character radii for precise collision detection
        const PLAYER_RADIUS = 35; // Half of 70px width
        const KID_RADIUS = 30;    // Half of 60px width
        
        // SOFT BOUNCE collision system
        const FOLLOW_STRENGTH = 0.02;
        const DAMPING = 0.92;
        const MAX_SPEED = 1;
        const PLAYER_SMOOTHING = 0.2;
        const UI_HEIGHT = 140;
        
        // Soft collision parameters
        const MIN_DISTANCE_PLAYER_TO_KID = PLAYER_RADIUS + KID_RADIUS + 10; // 75px
        const MIN_DISTANCE_KID_TO_KID = KID_RADIUS + KID_RADIUS + 10;      // 70px
        const SOFT_COLLISION_STRENGTH = 0.3; // How strong the repulsion is
        const COLLISION_DAMPING = 0.7; // How much velocity is reduced during collision
        
        // Speech bubble messages for kids
        const encouragingMessages = [
            "Love you Mama! üíï",
            "Happy Birthday! üéÇ"
        ];
        
        const laundryMessages = [
            "Laundry is annoying! üò§",
        ];

        const dishMessages = [
            "Let Dada do dishes! üö´",
        ];
        
        const winMessages = [
            "Happy Birthday From Charlie, Nova, and Dada! We Love You! üéâüíï"
        ];

        // Sound effects using Web Audio API
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function playSound(frequency, duration, type = 'sine') {
            if (!audioContext) return;
            try {
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = frequency;
                oscillator.type = type;
                
                gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                
                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + duration);
            } catch (e) {
                console.log('Audio context error:', e);
            }
        }

        function playCollectSound() {
            playSound(800, 0.2);
            setTimeout(() => playSound(1200, 0.1), 100);
        }

        function playNegativeSound() {
            playSound(200, 0.3, 'sawtooth');
            playSound(150, 0.4, 'square');
        }

        function playWinSound() {
            const notes = [523, 659, 784, 1047];
            notes.forEach((note, index) => {
                setTimeout(() => playSound(note, 0.3), index * 200);
            });
        }

        function shakeScreen() {
            gameContainer.classList.add('screen-shake');
            setTimeout(() => {
                gameContainer.classList.remove('screen-shake');
            }, 500);
        }

        function showScorePopup(x, y, points) {
            const popup = document.createElement('div');
            popup.className = `score-popup ${points > 0 ? 'positive' : 'negative'}`;
            popup.textContent = points > 0 ? `+${points}` : `${points}`;
            popup.style.left = x + 'px';
            popup.style.top = y + 'px';
            
            document.body.appendChild(popup);
            
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
            }, 1500);
        }

        // Initialize game
        function initGame() {
            console.log('Initializing game...');
            
            // Initialize player history
            for (let i = 0; i < maxHistoryLength; i++) {
                playerHistory.push({ x: playerX, y: playerY });
            }
            
            updatePlayerPosition();
            updateKidsPositions();
            createStaticElements();
            updateHighScore();
            
            // Touch controls with better responsiveness
            gameContainer.addEventListener('touchstart', handleTouch, { passive: false });
            gameContainer.addEventListener('touchmove', handleTouch, { passive: false });
            gameContainer.addEventListener('click', handleClick);
            
            // Button event listeners
            const startButton = document.getElementById('startButton');
            const restartButton = document.getElementById('restartButton');
            
            if (startButton) {
                startButton.addEventListener('click', startGame);
                console.log('Start button listener added');
            }
            
            if (restartButton) {
                restartButton.addEventListener('mousedown', handleRestartClick);
                restartButton.addEventListener('touchstart', handleRestartClick, { passive: false });
                console.log('Restart button listeners added');
            }
        }

        function handleRestartClick(e) {
            console.log('Restart button activated!');
            e.preventDefault();
            e.stopPropagation();
            e.stopImmediatePropagation();
            
            // Immediate visual feedback
            const button = e.target;
            button.style.transform = 'scale(0.9)';
            setTimeout(() => {
                button.style.transform = '';
            }, 150);
            
            // Execute restart
            restartGameImmediate();
        }

        function createStaticElements() {
            // Clear existing static elements
            document.querySelectorAll('.tree, .cloud').forEach(el => el.remove());
            
            const startY = UI_HEIGHT + 80;
            
            // Add many trees around the area
            const treePositions = [
                // Border trees
                {x: 50, y: startY + 40},
                {x: window.innerWidth - 130, y: startY + 40},
                {x: 50, y: window.innerHeight - 150},
                {x: window.innerWidth - 130, y: window.innerHeight - 150},
                
                // Scattered trees
                {x: window.innerWidth * 0.2, y: startY + 60},
                {x: window.innerWidth * 0.8, y: startY + 60},
                {x: window.innerWidth * 0.15, y: window.innerHeight * 0.6},
                {x: window.innerWidth * 0.85, y: window.innerHeight * 0.6},
                {x: window.innerWidth * 0.3, y: window.innerHeight - 180},
                {x: window.innerWidth * 0.7, y: window.innerHeight - 180},
                
                // Center area trees (sparse)
                {x: window.innerWidth * 0.1, y: window.innerHeight * 0.4},
                {x: window.innerWidth * 0.9, y: window.innerHeight * 0.4},
                {x: window.innerWidth * 0.5, y: startY + 30},
                {x: window.innerWidth * 0.25, y: window.innerHeight * 0.75},
                {x: window.innerWidth * 0.75, y: window.innerHeight * 0.25}
            ];
            
            treePositions.forEach(pos => {
                if (pos.y > startY && pos.x > 40 && pos.x < window.innerWidth - 120) {
                    const tree = document.createElement('div');
                    tree.className = 'tree';
                    tree.style.left = pos.x + 'px';
                    tree.style.top = pos.y + 'px';
                    gameContainer.appendChild(tree);
                }
            });
        }

        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            cloud.style.top = (UI_HEIGHT + 20 + Math.random() * 100) + 'px';
            cloud.style.left = '-80px';
            cloud.style.animationDuration = (15 + Math.random() * 10) + 's';
            gameContainer.appendChild(cloud);
            
            // Remove cloud after animation
            setTimeout(() => {
                if (cloud.parentNode) {
                    cloud.parentNode.removeChild(cloud);
                }
            }, 25000);
        }

        // Modify the createFlyingAirplane() function:
        function createFlyingAirplane() {
            if (!gameRunning) return;
            
            const airplane = document.createElement('div');
            airplane.className = 'flying-airplane';
            airplane.style.top = (UI_HEIGHT + 30 + Math.random() * 50) + 'px';
            airplane.style.left = '-100px';
            airplane.isAirplane = true; // Add identifier
            gameContainer.appendChild(airplane);
            
            // Add to collectibles array so it gets checked for collisions
            collectibles.push(airplane);
            
            // Keep the click handler as backup
            let collected = false;
            airplane.addEventListener('click', () => {
                if (!collected && gameRunning) {
                    collectAirplane(airplane);
                }
            });
            
            // Remove airplane after animation
            setTimeout(() => {
                if (airplane.parentNode) {
                    airplane.parentNode.removeChild(airplane);
                    // Remove from collectibles array
                    const index = collectibles.indexOf(airplane);
                    if (index > -1) collectibles.splice(index, 1);
                }
            }, 8000);
        }

        // Add a separate function to handle airplane collection:
        function collectAirplane(airplane) {
            const rect = airplane.getBoundingClientRect();
            showScorePopup(rect.left + rect.width/2, rect.top + rect.height/2, 100);
            score += 100;
            updateScore();
            playCollectSound();
            createParticles(airplane);
            
            // Remove from collectibles array
            const index = collectibles.indexOf(airplane);
            if (index > -1) collectibles.splice(index, 1);
            
            // Remove from DOM
            if (airplane.parentNode) {
                airplane.parentNode.removeChild(airplane);
            }
            
            if (!currentSpeakingKid) {
                const kid = Math.random() < 0.5 ? cassian : charlie;
                showSpeechBubble(kid, "Amazing catch! ‚úàÔ∏è‚ú®");
            }
        }

        function handleTouch(e) {
            e.preventDefault();
            if (!gameRunning) return;
            
            const touch = e.touches[0] || e.changedTouches[0];
            const rect = gameContainer.getBoundingClientRect();
            const touchX = touch.clientX - rect.left;
            const touchY = touch.clientY - rect.top;
            
            setPlayerTarget(touchX, touchY);
        }
        
        function handleClick(e) {
            if (!gameRunning) return;
            
            // Don't handle clicks on UI elements
            if (e.target.closest('#ui')) {
                return;
            }
            
            const rect = gameContainer.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            
            setPlayerTarget(clickX, clickY);
        }
        
        function setPlayerTarget(x, y) {
            // Ensure player stays well below UI
            targetX = Math.max(PLAYER_RADIUS, Math.min(window.innerWidth - PLAYER_RADIUS, x - PLAYER_RADIUS));
            targetY = Math.max(UI_HEIGHT + PLAYER_RADIUS, Math.min(window.innerHeight - PLAYER_RADIUS, y - PLAYER_RADIUS));
        }

        function updatePlayerPosition() {
            // Smooth interpolation to target position
            playerX += (targetX - playerX) * PLAYER_SMOOTHING;
            playerY += (targetY - playerY) * PLAYER_SMOOTHING;
            
            // Update player history for kids to follow
            playerHistory.push({ x: playerX, y: playerY });
            if (playerHistory.length > maxHistoryLength) {
                playerHistory.shift();
            }
            
            player.style.left = playerX + 'px';
            player.style.top = playerY + 'px';
        }

        // SOFT BOUNCE collision system - no teleporting
        function updateKidsPositions() {
            // Get delayed positions from player history for more natural following
            const cassianDelay = Math.floor(maxHistoryLength * 0.6);
            const charlieDelay = Math.floor(maxHistoryLength * 0.8);
            
            const cassianTarget = playerHistory[Math.max(0, playerHistory.length - cassianDelay - 1)];
            const charlieTarget = playerHistory[Math.max(0, playerHistory.length - charlieDelay - 1)];
            
            // Calculate center positions for collision detection
            const playerCenterX = playerX + PLAYER_RADIUS;
            const playerCenterY = playerY + PLAYER_RADIUS;
            const cassianCenterX = cassianX + KID_RADIUS;
            const cassianCenterY = cassianY + KID_RADIUS;
            const charlieCenterX = charlieX + KID_RADIUS;
            const charlieCenterY = charlieY + KID_RADIUS;
            
            // Add some wandering behavior to targets
            const time = Date.now() * 0.001;
            let cassianTargetX = cassianTarget.x + Math.sin(time * 0.5) * 25;
            let cassianTargetY = cassianTarget.y + Math.cos(time * 0.7) * 20;
            let charlieTargetX = charlieTarget.x + Math.cos(time * 0.6) * 30;
            let charlieTargetY = charlieTarget.y + Math.sin(time * 0.4) * 25;
            
            // Normal physics-based movement toward targets
            const cassianDist = Math.sqrt(Math.pow(cassianTargetX - cassianX, 2) + Math.pow(cassianTargetY - cassianY, 2));
            const cassianForceMultiplier = Math.min(cassianDist / 50, 1.5);
            
            const cassianForceX = (cassianTargetX - cassianX) * FOLLOW_STRENGTH * cassianForceMultiplier;
            const cassianForceY = (cassianTargetY - cassianY) * FOLLOW_STRENGTH * cassianForceMultiplier;
            
            cassianVelX += cassianForceX;
            cassianVelY += cassianForceY;
            
            const charlieDist = Math.sqrt(Math.pow(charlieTargetX - charlieX, 2) + Math.pow(charlieTargetY - charlieY, 2));
            const charlieForceMultiplier = Math.min(charlieDist / 50, 1.5);
            
            const charlieForceX = (charlieTargetX - charlieX) * FOLLOW_STRENGTH * charlieForceMultiplier;
            const charlieForceY = (charlieTargetY - charlieY) * FOLLOW_STRENGTH * charlieForceMultiplier;
            
            charlieVelX += charlieForceX;
            charlieVelY += charlieForceY;
            
            // SOFT COLLISION HANDLING - Kids with each other
            const kidDistance = Math.sqrt(Math.pow(charlieCenterX - cassianCenterX, 2) + Math.pow(charlieCenterY - cassianCenterY, 2));
            if (kidDistance < MIN_DISTANCE_KID_TO_KID && kidDistance > 0) {
                const overlap = MIN_DISTANCE_KID_TO_KID - kidDistance;
                const pushAngle = Math.atan2(charlieCenterY - cassianCenterY, charlieCenterX - cassianCenterX);
                
                // Soft repulsion force proportional to overlap
                const repulsionForce = overlap * SOFT_COLLISION_STRENGTH;
                
                // Apply repulsion to velocities (not positions)
                cassianVelX -= Math.cos(pushAngle) * repulsionForce;
                cassianVelY -= Math.sin(pushAngle) * repulsionForce;
                charlieVelX += Math.cos(pushAngle) * repulsionForce;
                charlieVelY += Math.sin(pushAngle) * repulsionForce;
                
                // Reduce velocities during collision for softer bounce
                cassianVelX *= COLLISION_DAMPING;
                cassianVelY *= COLLISION_DAMPING;
                charlieVelX *= COLLISION_DAMPING;
                charlieVelY *= COLLISION_DAMPING;
            }
            
            // SOFT COLLISION HANDLING - Cassian with player
            const cassianPlayerDistance = Math.sqrt(Math.pow(playerCenterX - cassianCenterX, 2) + Math.pow(playerCenterY - cassianCenterY, 2));
            if (cassianPlayerDistance < MIN_DISTANCE_PLAYER_TO_KID && cassianPlayerDistance > 0) {
                const overlap = MIN_DISTANCE_PLAYER_TO_KID - cassianPlayerDistance;
                const pushAngle = Math.atan2(cassianCenterY - playerCenterY, cassianCenterX - playerCenterX);
                
                // Soft repulsion from player
                const repulsionForce = overlap * SOFT_COLLISION_STRENGTH;
                cassianVelX += Math.cos(pushAngle) * repulsionForce;
                cassianVelY += Math.sin(pushAngle) * repulsionForce;
                
                // Dampen velocity during collision
                cassianVelX *= COLLISION_DAMPING;
                cassianVelY *= COLLISION_DAMPING;
            }
            
            // SOFT COLLISION HANDLING - Charlie with player
            const charliePlayerDistance = Math.sqrt(Math.pow(playerCenterX - charlieCenterX, 2) + Math.pow(playerCenterY - charlieCenterY, 2));
            if (charliePlayerDistance < MIN_DISTANCE_PLAYER_TO_KID && charliePlayerDistance > 0) {
                const overlap = MIN_DISTANCE_PLAYER_TO_KID - charliePlayerDistance;
                const pushAngle = Math.atan2(charlieCenterY - playerCenterY, charlieCenterX - playerCenterX);
                
                // Soft repulsion from player
                const repulsionForce = overlap * SOFT_COLLISION_STRENGTH;
                charlieVelX += Math.cos(pushAngle) * repulsionForce;
                charlieVelY += Math.sin(pushAngle) * repulsionForce;
                
                // Dampen velocity during collision
                charlieVelX *= COLLISION_DAMPING;
                charlieVelY *= COLLISION_DAMPING;
            }
            
            // Apply general damping
            cassianVelX *= DAMPING;
            cassianVelY *= DAMPING;
            charlieVelX *= DAMPING;
            charlieVelY *= DAMPING;
            
            // Limit speeds
            const cassianSpeed = Math.sqrt(cassianVelX * cassianVelX + cassianVelY * cassianVelY);
            const maxCassianSpeed = MAX_SPEED * (cassianDist > 100 ? 1.3 : 1);
            if (cassianSpeed > maxCassianSpeed) {
                cassianVelX = (cassianVelX / cassianSpeed) * maxCassianSpeed;
                cassianVelY = (cassianVelY / cassianSpeed) * maxCassianSpeed;
            }
            
            const charlieSpeed = Math.sqrt(charlieVelX * charlieVelX + charlieVelY * charlieVelY);
            const maxCharlieSpeed = MAX_SPEED * (charlieDist > 100 ? 1.3 : 1);
            if (charlieSpeed > maxCharlieSpeed) {
                charlieVelX = (charlieVelX / charlieSpeed) * maxCharlieSpeed;
                charlieVelY = (charlieVelY / charlieSpeed) * maxCharlieSpeed;
            }
            
            // Apply velocities to get new positions
            cassianX += cassianVelX;
            cassianY += cassianVelY;
            charlieX += charlieVelX;
            charlieY += charlieVelY;
            
            // Keep kids in bounds
            cassianX = Math.max(KID_RADIUS, Math.min(window.innerWidth - KID_RADIUS, cassianX));
            cassianY = Math.max(UI_HEIGHT + KID_RADIUS, Math.min(window.innerHeight - KID_RADIUS, cassianY));
            charlieX = Math.max(KID_RADIUS, Math.min(window.innerWidth - KID_RADIUS, charlieX));
            charlieY = Math.max(UI_HEIGHT + KID_RADIUS, Math.min(window.innerHeight - KID_RADIUS, charlieY));
            
            // Update DOM positions
            cassian.style.left = cassianX + 'px';
            cassian.style.top = cassianY + 'px';
            charlie.style.left = charlieX + 'px';
            charlie.style.top = charlieY + 'px';
        }

        function showSpeechBubble(kid, message) {
            if (currentSpeakingKid && currentSpeakingKid !== kid) {
                return;
            }

            const existingBubble = kid.querySelector('.speech-bubble');
            if (existingBubble) {
                existingBubble.remove();
            }
            
            currentSpeakingKid = kid;
            
            const bubble = document.createElement('div');
            bubble.className = 'speech-bubble';
            bubble.textContent = message;
            bubble.style.bottom = '65px';
            bubble.style.left = '50%';
            bubble.style.transform = 'translateX(-50%)';
            
            kid.appendChild(bubble);
            
            setTimeout(() => {
                bubble.classList.add('show');
            }, 50);
            
            setTimeout(() => {
                bubble.classList.remove('show');
                setTimeout(() => {
                    if (bubble.parentNode) {
                        bubble.remove();
                    }
                    if (currentSpeakingKid === kid) {
                        currentSpeakingKid = null;
                    }
                }, 300);
            }, 3000);
        }

        function startGame() {
            console.log('Starting game...');
            document.getElementById('startScreen').style.display = 'none';
            gameRunning = true;
            score = 0;
            timeLeft = 60;
            currentSpeakingKid = null;
            
            // Clear existing collectibles
            collectibles.forEach(collectible => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                }
            });
            collectibles = [];
            
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume();
            }
            
            updateScore();
            updateTimer();
            
            gameTimer = setInterval(() => {
                timeLeft--;
                updateTimer();
                
                if (timeLeft <= 0) {
                    endGame();
                }
            }, 1000);
            
            spawnTimer = setInterval(spawnCollectible, 150);
            
            speechTimer = setInterval(() => {
                if (Math.random() < 0.3 && !currentSpeakingKid) {
                    const kid = Math.random() < 0.5 ? cassian : charlie;
                    const message = encouragingMessages[Math.floor(Math.random() * encouragingMessages.length)];
                    showSpeechBubble(kid, message);
                }
            }, 4000);
            
            // Flying airplane every 12-20 seconds
            airplaneTimer = setInterval(() => {
                if (Math.random() < 0.6) {
                    createFlyingAirplane();
                }
            }, 15000);
            
            // Clouds every 8-15 seconds
            cloudTimer = setInterval(() => {
                if (Math.random() < 0.97) {
                    createCloud();
                }
            }, 1000);
            
            // Initial cloud and first airplane
            setTimeout(() => createCloud(), 2000);
            setTimeout(() => createFlyingAirplane(), 8000);
            
            setTimeout(() => {
                showSpeechBubble(cassian, "Go Mama! üí™");
            }, 1000);
        }

        function restartGameImmediate() {
            console.log('Executing immediate restart...');
            
            // Stop current game immediately
            gameRunning = false;
            
            // Clear all timers
            if (gameTimer) {
                clearInterval(gameTimer);
                gameTimer = null;
            }
            if (spawnTimer) {
                clearInterval(spawnTimer);
                spawnTimer = null;
            }
            if (speechTimer) {
                clearInterval(speechTimer);
                speechTimer = null;
            }
            if (airplaneTimer) {
                clearInterval(airplaneTimer);
                airplaneTimer = null;
            }
            if (cloudTimer) {
                clearInterval(cloudTimer);
                cloudTimer = null;
            }
            
            // Clear all visual elements
            document.querySelectorAll('.speech-bubble').forEach(bubble => bubble.remove());
            document.querySelectorAll('.score-popup').forEach(popup => popup.remove());
            document.querySelectorAll('.flying-airplane').forEach(plane => plane.remove());
            currentSpeakingKid = null;
            
            // Clear collectibles
            collectibles.forEach(collectible => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                }
            });
            collectibles = [];
            
            // Reset positions below UI with proper separation
            playerX = window.innerWidth / 2 - PLAYER_RADIUS;
            playerY = (window.innerHeight + UI_HEIGHT) / 2 - PLAYER_RADIUS;
            targetX = playerX;
            targetY = playerY;
            
            // Position kids at safe distances
            cassianX = playerX - MIN_DISTANCE_PLAYER_TO_KID - 20;
            cassianY = playerY + MIN_DISTANCE_PLAYER_TO_KID + 20;
            charlieX = playerX + MIN_DISTANCE_PLAYER_TO_KID + 20;
            charlieY = playerY - MIN_DISTANCE_PLAYER_TO_KID - 20;
            
            cassianVelX = 0;
            cassianVelY = 0;
            charlieVelX = 0;
            charlieVelY = 0;
            
            // Reset player history
            playerHistory = [];
            for (let i = 0; i < maxHistoryLength; i++) {
                playerHistory.push({ x: playerX, y: playerY });
            }
            
            // Update positions immediately
            updatePlayerPosition();
            updateKidsPositions();
            
            // Start new game immediately
            startGame();
        }

        function spawnCollectible() {
            if (!gameRunning) return;
            
            const positiveTypes = ['book', 'coffee', 'healthy-snack', 'running-shoe', 'apple', 'water', 'birthday-cake'];
            const negativeTypes = ['dirty-dish', 'laundry'];
            
            const isPositive = Math.random() < 0.75;
            const types = isPositive ? positiveTypes : negativeTypes;
            const type = types[Math.floor(Math.random() * types.length)];
            
            const collectible = document.createElement('div');
            collectible.className = `collectible ${type}`;
            
            let x, y, attempts = 0;
            let validPosition = false;
            const MIN_SPACING = 100; // Same spacing for all items now
            
            do {
                x = Math.random() * (window.innerWidth - 120) + 60;
                y = Math.random() * (window.innerHeight - UI_HEIGHT - 120) + UI_HEIGHT + 60;
                attempts++;
                
                validPosition = !isNearStaticElement(x, y, 120) && 
                               !isNearAnyCollectibles(x, y, MIN_SPACING) &&
                               !isNearPlayer(x, y, 140) &&
                               y > UI_HEIGHT + 80;
                
            } while (!validPosition && attempts < 100);
            
            if (!validPosition) {
                console.log('Could not find valid position for collectible after 100 attempts');
                return;
            }
            
            collectible.style.left = x + 'px';
            collectible.style.top = y + 'px';
            
            gameContainer.appendChild(collectible);
            collectibles.push(collectible);
            
            const lifetime = 8000 + Math.random() * 4000;
            setTimeout(() => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                    const index = collectibles.indexOf(collectible);
                    if (index > -1) collectibles.splice(index, 1);
                }
            }, lifetime);
        }

        function isNearAnyCollectibles(x, y, minDistance) {
            for (let collectible of collectibles) {
                const existingX = parseInt(collectible.style.left) + 30;
                const existingY = parseInt(collectible.style.top) + 30;
                
                const distance = Math.sqrt(Math.pow(x - existingX, 2) + Math.pow(y - existingY, 2));
                if (distance < minDistance) {
                    return true;
                }
            }
            return false;
        }

        function isNearStaticElement(x, y, minDistance = 100) {
            const elements = document.querySelectorAll('.tree');
            for (let element of elements) {
                const elementX = parseInt(element.style.left) + 40;
                const elementY = parseInt(element.style.top) + 50;
                
                const distance = Math.sqrt(Math.pow(x - elementX, 2) + Math.pow(y - elementY, 2));
                if (distance < minDistance) {
                    return true;
                }
            }
            return false;
        }
        
        function isNearPlayer(x, y, minDistance = 120) {
            const playerCenterX = playerX + PLAYER_RADIUS;
            const playerCenterY = playerY + PLAYER_RADIUS;
            const cassianCenterX = cassianX + KID_RADIUS;
            const cassianCenterY = cassianY + KID_RADIUS;
            const charlieCenterX = charlieX + KID_RADIUS;
            const charlieCenterY = charlieY + KID_RADIUS;
            
            const playerDistance = Math.sqrt(Math.pow(x - playerCenterX, 2) + Math.pow(y - playerCenterY, 2));
            const cassianDistance = Math.sqrt(Math.pow(x - cassianCenterX, 2) + Math.pow(y - cassianCenterY, 2));
            const charlieDistance = Math.sqrt(Math.pow(x - charlieCenterX, 2) + Math.pow(y - charlieCenterY, 2));
            
            return playerDistance < minDistance || 
                   cassianDistance < (minDistance * 0.8) || 
                   charlieDistance < (minDistance * 0.8);
        }

        // Collision detection with smaller hit boxes for negative items
        function checkCollisions() {
            collectibles.forEach((collectible, index) => {
                const rect1 = player.getBoundingClientRect();
                const rect2 = collectible.getBoundingClientRect();
                
                // Create smaller hit box for negative items
                const isNegativeItem = collectible.classList.contains('dirty-dish') || 
                                      collectible.classList.contains('laundry');
                
                let hitBoxLeft = rect2.left;
                let hitBoxRight = rect2.right;
                let hitBoxTop = rect2.top;
                let hitBoxBottom = rect2.bottom;
                
                if (isNegativeItem) {
                    // Shrink hit box by 15px on all sides for negative items
                    const shrinkAmount = 15;
                    hitBoxLeft += shrinkAmount;
                    hitBoxRight -= shrinkAmount;
                    hitBoxTop += shrinkAmount;
                    hitBoxBottom -= shrinkAmount;
                }
                
                // Check collision with adjusted hit box
                if (rect1.left < hitBoxRight && 
                    rect1.right > hitBoxLeft && 
                    rect1.top < hitBoxBottom && 
                    rect1.bottom > hitBoxTop) {
                    
                    collectCollectible(collectible, index);
                }
            });
        }

        // Modify the collectCollectible function to handle airplanes:
        function collectCollectible(collectible, index) {
            // Check if it's an airplane
            if (collectible.isAirplane) {
                collectAirplane(collectible);
                return;
            }
            
            // Rest of the existing collectCollectible code remains the same...
            const type = collectible.classList[1];
            let points = 0;
            let isNegative = false;
            
            switch(type) {
                case 'book': points = 25; break;
                case 'coffee': points = 20; break;
                case 'healthy-snack': points = 30; break;
                case 'running-shoe': points = 35; break;
                case 'apple': points = 15; break;
                case 'water': points = 15; break;
                case 'birthday-cake': points = 50; break;
                case 'dirty-dish': points = -20; isNegative = true; break;
                case 'laundry': points = -25; isNegative = true; break;
            }
            
            const rect = collectible.getBoundingClientRect();
            showScorePopup(rect.left + rect.width/2, rect.top + rect.height/2, points);
            
            score += points;
            updateScore();
            
            if (isNegative) {
                playNegativeSound();
                shakeScreen();
                collectible.classList.add('flex-hit');
                createNegativeParticles(collectible);
                
                if (!currentSpeakingKid) {
                    const kid = Math.random() < 0.5 ? cassian : charlie;
                    let message;
                    
                    if (type === 'laundry') {
                        message = laundryMessages[Math.floor(Math.random() * laundryMessages.length)];
                    } else if (type === 'dirty-dish') {
                        message = dishMessages[Math.floor(Math.random() * dishMessages.length)];
                    }
                    
                    showSpeechBubble(kid, message);
                }
            } else {
                playCollectSound();
                createParticles(collectible);
                
                if (Math.random() < 0.4 && !currentSpeakingKid) {
                    const kid = Math.random() < 0.5 ? cassian : charlie;
                    const positiveMessages = ["Happy Birthday Mama!!"];
                    const message = positiveMessages[Math.floor(Math.random() * positiveMessages.length)];
                    showSpeechBubble(kid, message);
                }
            }
            
            setTimeout(() => {
                if (collectible.parentNode) {
                    collectible.parentNode.removeChild(collectible);
                }
            }, 100);
            collectibles.splice(index, 1);
        }

        function createParticles(element) {
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < 12; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = (rect.left + rect.width/2 + Math.random() * 40 - 20) + 'px';
                particle.style.top = (rect.top + rect.height/2 + Math.random() * 40 - 20) + 'px';
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 3000);
            }
        }

        function createNegativeParticles(element) {
            const rect = element.getBoundingClientRect();
            for (let i = 0; i < 8; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle negative-particle';
                particle.style.left = (rect.left + rect.width/2 + Math.random() * 30 - 15) + 'px';
                particle.style.top = (rect.top + rect.height/2 + Math.random() * 30 - 15) + 'px';
                document.body.appendChild(particle);
                
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, 2000);
            }
        }

        function updateScore() {
            document.getElementById('score').textContent = `Score: ${score}`;
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('cafeQuestHighScore', highScore);
                updateHighScore();
            }
        }

        function updateHighScore() {
            document.getElementById('highScore').textContent = `High Score: ${highScore}`;
        }

        function updateTimer() {
            document.getElementById('timer').textContent = `Time: ${timeLeft}`;
        }

        function endGame() {
            gameRunning = false;
            clearInterval(gameTimer);
            clearInterval(spawnTimer);
            clearInterval(speechTimer);
            clearInterval(airplaneTimer);
            clearInterval(cloudTimer);
            
            playWinSound();
            
            if (!currentSpeakingKid) {
                showSpeechBubble(cassian, "You did great! üèÜ");
                setTimeout(() => {
                    if (!currentSpeakingKid) {
                        showSpeechBubble(charlie, "Love you Mom! üíï");
                    }
                }, 2000);
            }
            
            let finalMessage = "";
            finalMessage = winMessages[0];
            
            setTimeout(() => {
                showPopup("üéâ Game Complete! üéâ", 
                    `${finalMessage}<br><br>Final Score: ${score}<br>High Score: ${highScore}<br><br>You're amazing at 33! üíï<br>Cassian and Charlie are so proud of you!`);
            }, 3000);
        }

        function showPopup(title, message) {
            document.getElementById('popupTitle').textContent = title;
            document.getElementById('popupMessage').innerHTML = message;
            document.getElementById('popup').style.display = 'block';
        }

        function closePopup() {
            document.getElementById('popup').style.display = 'none';
        }

        // Game loop
        function gameLoop() {
            if (gameRunning) {
                updatePlayerPosition();
                updateKidsPositions();
                checkCollisions();
            }
            requestAnimationFrame(gameLoop);
        }

        // Initialize everything
        window.addEventListener('load', () => {
            console.log('Window loaded, initializing...');
            initGame();
            gameLoop();
        });

        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                createStaticElements();
            }, 100);
        });
    </script>
</body>
</html>
